import logging
import os
from io import BytesIO
import yaml
import base64
import ollama

from dotenv import load_dotenv
from PIL import Image
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

# Setup logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
OLLAMA_HOST = os.getenv("OLLAMA_HOST", "http://localhost:11434")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL")
USER = os.getenv("USER", "the user")  # Default to 'john' if USER is not set
ALLOWED_USER_IDS_STR = os.getenv("ALLOWED_USER_IDS")
ALLOWED_USER_IDS = [int(uid.strip()) for uid in ALLOWED_USER_IDS_STR.split(',')] if ALLOWED_USER_IDS_STR else []
SYSTEM_PROMPT = os.getenv("SYSTEM_PROMPT")
OLLAMA_NUM_PREDICT = os.getenv("OLLAMA_NUM_PREDICT")
USER_DATA_FILE = 'user_data.yaml'
DEFAULT_POLITE_NOTICE = f"Polite Notice: this caption is generated by a locally hosted AI model on an ARM Mac Mini, not by an online service or a data center. It may not be accurate or reliable. {USER} uses this method of alt text generation, because they have dyslexia and find writing alt-text mentally taxing"

# --- YAML data handling functions ---
def load_user_data():
    """Loads user data from the YAML file."""
    if not os.path.exists(USER_DATA_FILE):
        return {}
    try:
        with open(USER_DATA_FILE, 'r') as f:
            return yaml.safe_load(f) or {}
    except (yaml.YAMLError, IOError) as e:
        logger.error(f"Error loading user data from {USER_DATA_FILE}: {e}")
        return {}

def save_user_data(data):
    """Saves user data to the YAML file."""
    try:
        with open(USER_DATA_FILE, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)
    except IOError as e:
        logger.error(f"Error saving user data to {USER_DATA_FILE}: {e}")




async def set_suffix(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sets or removes a custom suffix for the user."""
    user_id = update.effective_user.id
    if ALLOWED_USER_IDS and user_id not in ALLOWED_USER_IDS:
        logger.warning(f"Unauthorized access attempt by user_id: {user_id} for /setpolitenotice command")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Sorry, you are not authorized to use this command."
        )
        return

    suffix_text = ' '.join(context.args)
    user_data = load_user_data()

    if not suffix_text:
        # Attempt to remove suffix
        if user_data.get('users', {}).get(user_id, {}).get('suffix') is not None:
            del user_data['users'][user_id]['suffix']
            if not user_data['users'][user_id]:  # Clean up empty user dict
                del user_data['users'][user_id]
            save_user_data(user_data)
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="Your custom suffix has been removed. The default will be used."
            )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="You don't have a polite notice  to remove. To set one, use: /setpolitenotice <your message>"
            )
        return

    # Set suffix
    user_data.setdefault('users', {}).setdefault(user_id, {})['suffix'] = suffix_text
    save_user_data(user_data)

    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Your custom suffix has been set."
    )


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sends a welcome message when the /start command is issued."""
    user_id = update.effective_user.id
    if ALLOWED_USER_IDS and user_id not in ALLOWED_USER_IDS:
        logger.warning(f"Unauthorized access attempt by user_id: {user_id}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Sorry, you are not authorized to use this bot."
        )
        return

    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Hello! I'm an image captioning bot. Send me an image, and I'll tell you what I see."
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sends a help message with all available commands."""
    help_text = (
        "Welcome to the Image Captioning Bot! Here's how to use me:\n\n"
        "To generate a caption, simply send an image.\n"
        "To guide the caption generation, provide a text prompt in the image's caption. The model will use your prompt to focus its description. For example, sending an image with the caption 'A black dog playing fetch' will guide the model.\n\n"
        "To extract text from an image (OCR), send the image with the caption `/ocr`.\n\n"
        "Available commands:\n"
        "/start - Get a welcome message.\n"
        "/help - Show this help message.\n"
        "/setpolitenotice <your message> - Set a custom suffix for your captions. "
        "To remove it, use the command without a message."
    )
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=help_text
    )

def image_to_base64(image: Image.Image) -> str:
    """Converts a PIL image to a base64 encoded string."""
    buffered = BytesIO()
    image.save(buffered, format="JPEG")
    return base64.b64encode(buffered.getvalue()).decode('utf-8')

def generate_caption(image: Image.Image, user_prompt: str) -> str:
    """Generates a caption for the given image using the Ollama API."""
    logger.info(f"Generating caption for image with user prompt: '{user_prompt}'")

    try:
        client = ollama.Client(host=OLLAMA_HOST)
        image_b64 = image_to_base64(image)

        # Construct the prompt
        prompt_text = "Describe the image."
        if user_prompt:
            prompt_text = f"Please describe this image, paying special attention to: {user_prompt}"

        # Use a default system prompt if not provided
        system_prompt = SYSTEM_PROMPT if SYSTEM_PROMPT else "You are a helpful assistant that describes images in detail."

        # Construct options for the Ollama client
        options = {}
        if OLLAMA_NUM_PREDICT and OLLAMA_NUM_PREDICT.isdigit():
            options['num_predict'] = int(OLLAMA_NUM_PREDICT)
            logger.info(f"Setting num_predict (max tokens) to {options['num_predict']}")

        response = client.chat(
            model=OLLAMA_MODEL,
            messages=[
                {
                    'role': 'system',
                    'content': system_prompt,
                },
                {
                    'role': 'user',
                    'content': prompt_text,
                    'images': [image_b64]
                }
            ],
            options=options
        )
        raw_caption = response['message']['content'].strip()
        logger.info(f"Raw generated caption from model: '{raw_caption}'")

        # Extract content between <Description> tags
        try:
            start_tag = "<Description>"
            end_tag = "</Description>"
            start_index = raw_caption.index(start_tag) + len(start_tag)
            end_index = raw_caption.index(end_tag, start_index)
            caption = raw_caption[start_index:end_index].strip()
            logger.info(f"Extracted caption: '{caption}'")
        except ValueError:
            logger.warning("Could not find <Description> tags in the output. Using raw output.")
            caption = raw_caption

        return caption
    except Exception as e:
        logger.error(f"Failed to generate caption with Ollama: {e}")
        raise

def generate_ocr_text(image: Image.Image) -> str:
    """Extracts text from the given image using the Ollama API for OCR."""
    logger.info("Performing OCR on image.")

    try:
        client = ollama.Client(host=OLLAMA_HOST)
        image_b64 = image_to_base64(image)

        system_prompt = "You are an expert at Optical Character Recognition (OCR). Your task is to accurately transcribe the text from the provided image. Preserve the original formatting, including line breaks, as closely as possible. If the image contains no text, respond with 'No text found in the image.'"
        prompt_text = "Transcribe the text from this image."

        # Construct options for the Ollama client
        options = {}
        if OLLAMA_NUM_PREDICT and OLLAMA_NUM_PREDICT.isdigit():
            options['num_predict'] = int(OLLAMA_NUM_PREDICT)
            logger.info(f"Setting num_predict (max tokens) to {options['num_predict']}")

        response = client.chat(
            model=OLLAMA_MODEL,
            messages=[
                {
                    'role': 'system',
                    'content': system_prompt,
                },
                {
                    'role': 'user',
                    'content': prompt_text,
                    'images': [image_b64]
                }
            ],
            options=options
        )
        ocr_text = response['message']['content'].strip()
        logger.info(f"Extracted OCR text: '{ocr_text}'")
        return ocr_text
    except Exception as e:
        logger.error(f"Failed to perform OCR with Ollama: {e}")
        raise


async def handle_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles incoming photos, generates a caption, or performs OCR."""
    user_id = update.effective_user.id
    if ALLOWED_USER_IDS and user_id not in ALLOWED_USER_IDS:
        logger.warning(f"Unauthorized access attempt by user_id: {user_id}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Sorry, you are not authorized to use this bot."
        )
        return

    chat_id = update.effective_chat.id
    logger.info(f"Received image from chat_id: {chat_id}")

    user_prompt = update.message.caption.strip() if update.message.caption else ""

    await context.bot.send_message(chat_id=chat_id, text="Processing your image...")

    # Get the largest photo sent
    photo_file = await update.message.photo[-1].get_file()

    # Download the photo into a BytesIO object
    file_bytes = await photo_file.download_as_bytearray()
    image_stream = BytesIO(file_bytes)

    try:
        image = Image.open(image_stream).convert("RGB")

        # Resize the image to a maximum dimension to conserve memory before processing
        max_dim = 2048
        if image.width > max_dim or image.height > max_dim:
            image.thumbnail((max_dim, max_dim))
            logger.info(f"Resized image to {image.size} to conserve memory.")

        if user_prompt.lower() == "/ocr":
            logger.info("OCR command detected.")
            ocr_text = generate_ocr_text(image)
            await context.bot.send_message(chat_id=chat_id, text=f"Extracted Text (OCR):\n\n{ocr_text}")
        else:
            caption = generate_caption(image, user_prompt)
            user_data = load_user_data()
            user_suffix = user_data.get('users', {}).get(user_id, {}).get('suffix', DEFAULT_POLITE_NOTICE)
            await context.bot.send_message(chat_id=chat_id, text=f"{caption}\n\n{user_suffix}")
    except Exception as e:
        logger.error(f"An error occurred while processing the image: {e}")
        await context.bot.send_message(chat_id=chat_id, text="Sorry, I couldn't process that image.")


def main():
    """Start the bot."""
    if not TELEGRAM_BOT_TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN not found. Please create a .env file and add it.")
        return

    if not OLLAMA_MODEL:
        logger.error("OLLAMA_MODEL not found in .env file. Please specify the Ollama model to use.")
        return

    # Check if Ollama server is reachable
    try:
        client = ollama.Client(host=OLLAMA_HOST)
        client.list()
        logger.info(f"Successfully connected to Ollama at {OLLAMA_HOST}")
    except Exception as e:
        logger.error(f"Could not connect to Ollama at {OLLAMA_HOST}. Please ensure Ollama is running. Error: {e}")
        return

    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("setpolitenotice", set_suffix))
    application.add_handler(MessageHandler(filters.PHOTO, handle_image))

    logger.info("Bot is running. Press Ctrl-C to stop.")
    application.run_polling()


if __name__ == '__main__':
    main()
